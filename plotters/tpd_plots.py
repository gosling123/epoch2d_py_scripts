#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
tpd_plots.py 

File that houses class for defining TPD plot curves
"""

# Import libraries
import sys
sys.path.append("..")
import matplotlib.pyplot as plt
import numpy as np
import calculations.tpd_calculator as tpd
import calculations.plasma_calculator as plasma

# Set colour for plot
plot_colour = 'lime'


class plots:
    """ Class housing functions to call for plotting TPD curves"""

    def __init__(self, T_e, lambda_0):

        """
        Class constructor function

        T_e = Electron temperature (units : K)
        lambda_0 = Laser wavelength in vacuum (units : m)
        """

        # Base laser plasma variables required
        self.T_e = T_e
        self.lambda_0 = lambda_0

        # Electron thermal speed (key varibale for most plots)
        self.v_th = plasma.electron_thermal_speed(self.T_e)

    ########################################################################################################################
    # kx vs omega
    ########################################################################################################################

    def kx_vs_omega(self, n_e, theta, ax):
        
        """
        Plots the curve for expcted wavenumbers (kx) and
        frequencies at a given desnities of scattered EPW's
        generated by TPD.

        n_e = Densities to calculate wavenumbers and frequencies at (units : n_cr)
        theta = Angle of scatter that defines TPD process. Angle is defined
                as the angle between vectors k - k_0/2 and k_0. (units : degrees) 
        ax = Name of plot to plot onto (best to use plt.gca())
        """

        # Get wavenumbers and frequencies for scattered EPW's
        k1, k2 = tpd.tpd_wns_pairs(self.v_th, n_e, theta, self.lambda_0, componants = 'x')
        omega1, omega2 = tpd.tpd_omegas(n_e, self.T_e, theta, self.lambda_0)
        # Plot
        ax.plot(k1, omega1, c=plot_colour)
        ax.plot(k2, omega2, c=plot_colour)

    ########################################################################################################################
    # x vs omega
    ########################################################################################################################

    def x_vs_omega(self, n_e, theta, x, ax):

        """
        Plots the curve for expcted frequencies at a 
        spatial/desnity location.

        n_e = Densities to calculate wavenumbers and frequencies at (units : n_cr)
        theta = Angle of scatter that defines TPD process. Angle is defined
                as the angle between vectors k - k_0/2 and k_0. (units : degrees) 
        x = Spatial scale to plot over (units : m)
        ax = Name of plot to plot onto (best to use plt.gca())
        """

        # Get frequencies
        omega1, omega2 = tpd.tpd_omegas(n_e, self.T_e, theta, self.lambda_0)

        # Plot
        ax.plot(x, omega1, c=plot_colour)
        if theta == 'max_lin_growth':
            ax.plot(x, omega2, c=plot_colour, label = r'TPD EPW ($\theta = \theta_{MLG}$')
        else:
            ax.plot(x, omega2, c=plot_colour, label = r'TPD EPW ($\theta$ =' + f'{np.round(theta, 1)}\N{DEGREE SIGN})')

    
    ########################################################################################################################
    # omega range 
    ########################################################################################################################

    def omega(self, axis, n_min, n_max, ax):

        """
        Finds the range of frequncies for scattred EPW's
        from TPD for a given density range.

        axis = Sets oreintation of plot. Either = 'x' or 'y'.
        n_min = Minimum density (units : n_cr)
        n_max = Maximum density (units : n_cr)
        ax = Name of plot to plot onto (best to use plt.gca())
        """

        # Take number density points
        num_dens = np.linspace(n_min, n_max, 50)
        # Look for all angles
        angles = np.linspace(0, 360, 50)

        # Store max and min values
        omega_min = np.zeros(len(angles))
        omega_max = np.zeros(len(angles))
        
        for i in range(len(angles)):
            omega1, omega2 = tpd.tpd_omegas(num_dens, self.T_e, angles[i], self.lambda_0)
            # Extract min/max frequncies for given angle
            idx1 = np.where(np.isnan(omega1) == False)[0]
            idx2 = np.where(np.isnan(omega2) == False)[0]
            omega_min[i] = min(omega1[idx1].min(),omega2[idx2].min())
            omega_max[i] = min(omega1[idx1].max(),omega2[idx2].max())
        
        # Plots bounds to get idea of range of frequcies relating to scattered EPW's due to TPD
        if axis == 'x':
            ax.axvline(omega_min.min(), c=plot_colour)
            ax.axvline(omega_max.max(), c=plot_colour, label = f'TPD ({n_min}-{n_max}' + r' $n_{cr}$)')
        elif axis == 'y':
            ax.axhline(omega_min.min(), c=plot_colour)
            ax.axhline(omega_max.max(), c=plot_colour, label = f'TPD ({n_min}-{n_max}' + r' $n_{cr}$)')

    ########################################################################################################################
    # kx vs ky
    ########################################################################################################################


    def kx_vs_ky(self, n_vals, angle_range, ax):

        """
        Finds the wavevector componants for scattred EPW's
        from TPD for a given densities.

        n_vals = List of density values to plot for (units : n_cr)
        angle_range = Range of scattering angles to plot for [theta_min, theta_max] (units : degrees)
        ax = Name of plot to plot onto (best to use plt.gca())
        """
        
        # For if n_vals is given of the form n_vals = {num}
        if np.isscalar(n_vals):
            # Extract k componants
            k_x, k_y = tpd.tpd_wns_polar(n_vals, self.v_th, self.lambda_0, angle_range[0], angle_range[-1])
            # Plot
            ax.plot(k_x, k_y, c=plot_colour, label = f'TPD EPW ($n_e$ = ' + f'{np.round(n_vals,2)}' + r' $n_{cr}$)')
        else:
            for i in range(len(n_vals)):
                # Extract k componants at each density
                k_x, k_y = tpd.tpd_wns_polar(n_vals[i], self.v_th, self.lambda_0, angle_range[0], angle_range[-1])
                # Plot
                if i == 0:
                    # Just so only one label is present in legend
                    ax.plot(k_x, k_y, c=plot_colour, label = r'TPD EPW ($n_e$ = '+ f'{np.round(np.array(n_vals).min(),2)} - {np.round(np.array(n_vals).max(),2)}' + r' $n_{cr}$)')
                else:
                    ax.plot(k_x, k_y, c=plot_colour)

        # Plot linear growth rate curve for max density asked to plot
        # Curve is very similar for all k_L values (i.e for all n_e values)
        k_x_growth, k_y_growth = tpd.tpd_max_lin_growth(np.array(n_vals).max(), self.lambda_0)
        # Have postive and negative solutions
        ax.plot(k_x_growth, k_y_growth, c=plot_colour, ls = '--')
        ax.plot(k_x_growth, -k_y_growth, c=plot_colour, ls = '--', label = 'TPD Growth Curve')

    ########################################################################################################################
    # x vs ky
    ########################################################################################################################

    def x_vs_ky(self, n_e, theta, x, ax):

        """
        Plots the curve for expcted wavenumbers (ky) at a 
        spatial/desnity location. 

        n_e = Densities to calculate wavenumbers and frequencies at (units : n_cr)
        theta = Angle of scatter that defines TPD process. Angle is defined
                as the angle between vectors k - k_0/2 and k_0. (units : degrees) 
        x = Spatial scale to plot over (units : m)
        ax = Name of plot to plot onto (best to use plt.gca())
        """

        # Extract componants and plot
        k1_y, k2_y = tpd.tpd_wns_pairs(self.v_th, n_e, theta, self.lambda_0, componants = 'y')
        ax.plot(x, k1_y, c=plot_colour)
        if theta == 'max_lin_growth':
            ax.plot(x, k2_y, c=plot_colour, label = r'TPD EPW ($\theta$ = $\theta_{MLG}$)')
        else:
            ax.plot(x, k2_y, c=plot_colour, label = r'TPD EPW ($\theta$ =' + f'{np.round(theta, 1)}\N{DEGREE SIGN})')
        
        # No need to plot conjugate as k1_y = -k2_y

        # Find location where LW are Landau damped
        landau_cutoff_tpd = tpd.landau_cutoff_index(self.T_e, n_e, self.lambda_0, theta, cutoff = 0.3)
        if landau_cutoff_tpd is not None:
            if theta == 'max_lin_growth':
                ax.axvline(x[landau_cutoff_tpd], ls = '--', c=plot_colour, label = r'TPD Landau Cutoff ($\theta$ = $\theta_{MLG}$)')
            else:
                ax.axvline(x[landau_cutoff_tpd], ls = '--', c=plot_colour, label = r'TPD Landau Cutoff ($\theta$ =' + f'{np.round(theta, 1)}\N{DEGREE SIGN})')

    def x_vs_kx(self, n_e, theta, x, ax):

        """
        Plots the curve for expcted wavenumbers (kx) at a 
        spatial/desnity location. 

        n_e = Densities to calculate wavenumbers and frequencies at (units : n_cr)
        theta = Angle of scatter that defines TPD process. Angle is defined
                as the angle between vectors k - k_0/2 and k_0. (units : degrees) 
        x = Spatial scale to plot over (units : m)
        ax = Name of plot to plot onto (best to use plt.gca())
        """

        # Extract componants and plot
        k1_x, k2_x = tpd.tpd_wns_pairs(self.v_th, n_e, theta, self.lambda_0, componants = 'x')
        ax.plot(x, k1_x, c=plot_colour)
        if theta == 'max_lin_growth':
            ax.plot(x, k2_x, c=plot_colour, label = r'TPD EPW ($\theta$ = $\theta_{MLG}$)')
        else:
            ax.plot(x, k2_x, c=plot_colour, label = r'TPD EPW ($\theta$ =' + f'{np.round(theta, 1)}\N{DEGREE SIGN})')

        # Plot for FFT conjugate
        ax.plot(x, -k1_x, c=plot_colour)
        ax.plot(x, -k2_x, c=plot_colour)

        # # Find location where LW are Landau damped
        # landau_cutoff_tpd = tpd.landau_cutoff_index(self.T_e, n_e, self.lambda_0, theta, cutoff = 0.3)
        # if landau_cutoff_tpd is not None:
        #     if theta == 'max_lin_growth':
        #         ax.axvline(x[landau_cutoff_tpd], ls = '--', c=plot_colour, label = r'TPD Landau Cutoff ($\theta$ = $\theta_{MLG}$)')
        #     else:
        #         ax.axvline(x[landau_cutoff_tpd], ls = '--', c=plot_colour, label = r'TPD Landau Cutoff ($\theta$ =' + f'{np.round(theta, 1)}\N{DEGREE SIGN})')
